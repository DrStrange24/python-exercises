import networkx as nx
import matplotlib.pyplot as plt
from typing import List, Optional
from networkx import DiGraph

class BinaryTree:
    class Node:
        def __init__(s, val = None):
            s.val = val
            s.left: Optional[BinaryTree.Node] = None
            s.right: Optional[BinaryTree.Node] = None

    root: Optional[Node]

    def init_tree(s,list):
        if len(list) == 0:
            print('please insert a list')
            return
        s.root = BinaryTree.Node(list[0])
        q = [s.root]
        i = 1
        while i < len(list):
            cur_root = q.pop(0)
            if list[i]:
                cur_root.left = BinaryTree.Node(list[i])
                q.append(cur_root.left)
            i+=1
            if i < len(list) and list[i]:
                cur_root.right = BinaryTree.Node(list[i])
                q.append(cur_root.right)
            i+=1

    def show_tree(s):
        """generated by chatgpt"""
        def add_edges(graph:DiGraph, node: BinaryTree.Node, pos, x=0, y=0, layer=1):
            pos[node.val] = (x, y)
            if node.left:
                graph.add_edge(node.val, node.left.val)
                l = x - 1 / layer
                add_edges(graph, node.left, pos, l, y - 1, layer + 1)
            if node.right:
                graph.add_edge(node.val, node.right.val)
                r = x + 1 / layer
                add_edges(graph, node.right, pos, r, y - 1, layer + 1)
        
        graph = nx.DiGraph()
        pos = {}
        add_edges(graph, s.root, pos)
        nx.draw(graph, pos, with_labels=True, arrows=False)
        plt.show()
    
    def find(s, val, root:Node = None) -> Optional[Node]:
        r = root if root is not None else s.root
        if r is None:
            print('the tree is empty')
            return

        stack = [r]
        while stack:
            cur_node = stack.pop()
            if cur_node.val == val:
                return cur_node
            if cur_node.right: stack.append(cur_node.right)
            if cur_node.left: stack.append(cur_node.left)

        print('the node value doesnt exist')
        return

    def get_leaves(s,node:Node) -> List[Node]:
        if s.is_leaf(node):
            print('no leaves')
            return
        children = []
        if node.left: children.append(node.left)
        if node.right: children.append(node.right)
        return children

    def get_height(s)->int:
        pass

    def get_depth(s)->int:
        pass

    def is_leaf(s,node:Node) -> bool:
        return not (node.left or node.right)

    def is_empty(s) -> bool: 
        return s.root is None

    def is_siblings(s,node1:Node,node2:Node)->bool:
        pass

    def is_cousins(s,node1:Node,node2:Node)->bool:
        pass

    def remove(s,node:Node):
        pass

    def parent(s,node:Node)->Optional[Node]:
        stack = [s.root]
        while stack:
            cur_s = stack.pop()
            
        print('parent not found')
        return

def practice_binary_tree():
    bt = BinaryTree()
    
    bt.init_tree([1,2,3,4,5,6,7])

    subtree = bt.find(3)

    for leaf in bt.get_leaves(subtree):
        print(leaf.val)

    BinaryTree.find(bt,5,subtree)
    BinaryTree.find(None,5,subtree)

    print(bt.is_leaf(subtree))
    print(bt.is_leaf(subtree.right))

    subtree.left.left = BinaryTree.Node(8)
    subtree.left.right = BinaryTree.Node(9)
    subtree.val = 10

    bt.show_tree()

    # bt.init_tree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
    # bt.show_tree()

    # bt.init_tree([1,2,3,None,4,5,None,6,7,None,9,None,None,None,None,10,11])
    # bt.show_tree()