import networkx as nx
import matplotlib.pyplot as plt
from typing import List, Optional
from networkx import DiGraph

class BinaryTree:
    class Node:
        def __init__(s, val = None):
            s.val = val
            s.left: Optional[BinaryTree.Node] = None
            s.right: Optional[BinaryTree.Node] = None

    root: Optional[Node]

    def init_tree(s,list):
        if len(list) == 0:
            print('please insert a list')
            return
        s.root = BinaryTree.Node(list[0])
        q = [s.root]
        i = 1
        while i < len(list):
            cur_root = q.pop(0)
            if list[i]:
                cur_root.left = BinaryTree.Node(list[i])
                q.append(cur_root.left)
            i+=1
            if i < len(list) and list[i]:
                cur_root.right = BinaryTree.Node(list[i])
                q.append(cur_root.right)
            i+=1

    def show_tree(s):
        """generated by chatgpt"""
        def add_edges(graph:DiGraph, node: BinaryTree.Node, pos, x=0, y=0, layer=1):
            pos[node.val] = (x, y)
            if node.left:
                graph.add_edge(node.val, node.left.val)
                l = x - 1 / layer
                add_edges(graph, node.left, pos, l, y - 1, layer + 1)
            if node.right:
                graph.add_edge(node.val, node.right.val)
                r = x + 1 / layer
                add_edges(graph, node.right, pos, r, y - 1, layer + 1)
        
        graph = nx.DiGraph()
        pos = {}
        add_edges(graph, s.root, pos)
        nx.draw(graph, pos, with_labels=True, arrows=False)
        plt.show()
    
    @staticmethod
    def _private_static_find(r:Node,val):
        if r is None:
            print('the tree is empty')
            return

        stack = [r]
        while stack:
            cur_node = stack.pop()
            if cur_node.val == val:
                return cur_node
            if cur_node.right: stack.append(cur_node.right)
            if cur_node.left: stack.append(cur_node.left)

        print('the node value doesnt exist')
        return

    def find_recursive(s,val):
        if s.root is None:
            print('the tree is empty')
            return
        def recursive(cur_node:BinaryTree.Node):
            print(cur_node.val)
            if cur_node.left: recursive(cur_node.left)
            if cur_node.right: recursive(cur_node.right)
        return recursive(s.root)
    
    def to_list_pre_order(s):
        '''root => left => right'''
        if s.root is None:
            print('the tree is empty')
            return
        res = []
        def traverse(cur_node:BinaryTree.Node):
            if cur_node is None: return
            res.append(cur_node.val)
            traverse(cur_node.left)
            traverse(cur_node.right)
        traverse(s.root)
        return res
    
    def to_list_in_order(s):
        '''left => root => right'''
        if s.root is None:
            print('the tree is empty')
            return
        res = []
        def traverse(cur_node:BinaryTree.Node):
            if cur_node is None: return
            traverse(cur_node.left)
            res.append(cur_node.val)
            traverse(cur_node.right)
        traverse(s.root)
        return res
    
    def to_list_post_order(s):
        '''left => right => root'''
        if s.root is None:
            print('the tree is empty')
            return
        res = []
        def traverse(cur_node:BinaryTree.Node):
            if cur_node is None: return
            traverse(cur_node.left)
            traverse(cur_node.right)
            res.append(cur_node.val)
        traverse(s.root)
        return res
    
    def to_list_level_order(s):
        '''breadth first search'''
        if s.root is None:
            print('the tree is empty')
            return
        q = [s.root]
        res = []
        while q:
            cur_node = q.pop(0)
            res.append(cur_node.val)
            if cur_node.left: q.append(cur_node.left)
            if cur_node.right: q.append(cur_node.right)
        return res
    
    def find(s, val):
        return BinaryTree._private_static_find(s.root,val)

    @staticmethod
    def _static_find(root:Node, val):
        return BinaryTree._private_static_find(root,val)

    @staticmethod
    def _static_get_leaves(node:Node) -> List[Node]:
        if BinaryTree._static_is_leaf(node):
            print('no leaves')
            return
        children = []
        if node.left: children.append(node.left)
        if node.right: children.append(node.right)
        return children
    
    @staticmethod
    def _static_is_leaf(node:Node) -> bool:
        return not (node.left or node.right)

    def is_empty(s) -> bool: 
        return s.root is None

    def remove(s,node:Node):
        stack = [s.root]
        while stack:
            cur_node = stack.pop()
            if cur_node.right:
                if cur_node.right.val == node.val:
                    cur_node.right = None
                    return
                stack.append(cur_node.right)
            if cur_node.left:
                if cur_node.left.val == node.val:
                    cur_node.left = None
                    return
                stack.append(cur_node.left)
        print('node not found')

    def parent(s,node:Node):
        stack = [s.root]
        while stack:
            cur_node = stack.pop()
            if cur_node.right:
                if cur_node.right.val == node.val:
                    return cur_node
                stack.append(cur_node.right)
            if cur_node.left:
                if cur_node.left.val == node.val:
                    return cur_node
                stack.append(cur_node.left)
            
        print('parent not found')
        return

    def get_height(s)->int:
        if s.is_empty():
            print('tree is empty')
            return
        q = [s.root]
        h = -1
        while q:
            cur_level = len(q)
            for _ in range(cur_level):
                cur_node = q.pop(0)
                if cur_node.left: q.append(cur_node.left)
                if cur_node.right: q.append(cur_node.right)
            h+=1
        return h

    def get_depth(s,node):
        if s.is_empty():
            print('tree is empty')
            return
        q = [(s.root,0)]
        while q:
            cur_level = len(q)
            for _ in range(cur_level):
                cur_node,depth = q.pop(0)
                if cur_node == node: return depth
                if cur_node.left: q.append((cur_node.left,depth+1))
                if cur_node.right: q.append((cur_node.right,depth+1))
        print('node not found')
        return

    def is_siblings(s,node1:Node,node2:Node)->bool:
        stack = [s.root]
        while stack:
            cur_node = stack.pop()
            if cur_node.right:
                if cur_node.right.val == node1.val: return cur_node.left.val == node2.val
                stack.append(cur_node.right)
            if cur_node.left:
                if cur_node.left.val == node1.val: return cur_node.right.val == node2.val
                stack.append(cur_node.left)
    
    def is_siblings_chatgpt_3(s, node1, node2):
        if s.root is None or node1 is None or node2 is None: return False
        stack = [(s.root, None)]
        node1_parent, node2_parent = None, None
        while stack and (not node1_parent or not node2_parent):
            cur_node, parent_node = stack.pop()
            if cur_node == node1: node1_parent = parent_node
            elif cur_node == node2: node2_parent = parent_node
            if cur_node.right: stack.append((cur_node.right, cur_node))
            if cur_node.left: stack.append((cur_node.left, cur_node))
        return node1_parent and node2_parent and node1_parent == node2_parent

    def is_cousins_chatgpt_3(s,node1:Node,node2:Node)->bool:
        if s.root is None or node1 is None or node2 is None: return False

        stack = [(s.root, None, 0)]  # Stack to store nodes, their parent, and depth

        node1_depth = None
        node2_depth = None
        node1_parent = None
        node2_parent = None

        while stack and (node1_depth is None or node2_depth is None):
            cur_node, parent_node, depth = stack.pop()

            if cur_node == node1:
                node1_depth = depth
                node1_parent = parent_node
            elif cur_node == node2:
                node2_depth = depth
                node2_parent = parent_node

            if cur_node.right: stack.append((cur_node.right, cur_node, depth + 1))
            if cur_node.left: stack.append((cur_node.left, cur_node, depth + 1))

        return node1_depth == node2_depth and node1_parent != node2_parent

def practice_binary_tree():
    bt = BinaryTree()
    
    bt.init_tree([1,2,3,4,5,6,7])

    subtree = bt.find(3)

    for leaf in BinaryTree._static_get_leaves(subtree):
        print(leaf.val)

    BinaryTree._static_find(subtree,5)

    print(BinaryTree._static_is_leaf(subtree))
    print(BinaryTree._static_is_leaf(subtree.right))

    subtree.left.left = BinaryTree.Node(8)
    subtree.left.right = BinaryTree.Node(9)
    subtree.val = 10

    print('parent of 9',bt.parent(bt.find(9)).val)

    print('height',bt.get_height())

    bt.show_tree()

    bt.remove(bt.find(6))

    print('height',bt.get_height())

    print('depth from 2',bt.get_depth(bt.find(2)))

    bt.show_tree()

    bt.init_tree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])

    print('4,5 is_siblings:',bt.is_siblings(bt.find(4),bt.find(5)))
    print('5,6 is_siblings:',bt.is_siblings(bt.find(5),bt.find(6)))
    print('6,7 is_siblings:',bt.is_siblings(bt.find(6),bt.find(7)))

    print('4,5 is_siblings:',bt.is_siblings_chatgpt_3(bt.find(4),bt.find(5)))
    print('5,6 is_siblings:',bt.is_siblings_chatgpt_3(bt.find(5),bt.find(6)))
    print('6,7 is_siblings:',bt.is_siblings_chatgpt_3(bt.find(6),bt.find(7)))

    print('5,6 is_cousins:',bt.is_cousins_chatgpt_3(bt.find(5),bt.find(6)))
    print('2,3 is_cousins:',bt.is_cousins_chatgpt_3(bt.find(2),bt.find(3)))
    print('8,15 is_cousins:',bt.is_cousins_chatgpt_3(bt.find(8),bt.find(15)))

    print(bt.to_list_pre_order())
    print(bt.to_list_in_order())
    print(bt.to_list_post_order())
    print(bt.to_list_level_order())

    # subtree = bt.find_recursive(7)
    
    bt.show_tree()

    # bt.init_tree([1,2,3,None,4,5,None,6,7,None,9,None,None,None,None,10,11])
    # bt.show_tree()