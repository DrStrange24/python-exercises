import networkx as nx
import matplotlib.pyplot as plt
from typing import List, Optional
from networkx import DiGraph

class BinaryTree:
    class Node:
        def __init__(s, val = None):
            s.val = val
            s.left: Optional[BinaryTree.Node] = None
            s.right: Optional[BinaryTree.Node] = None

    root: Optional[Node]

    def init_tree(s,list):
        if len(list) == 0:
            print('please insert a list')
            return
        s.root = BinaryTree.Node(list[0])
        q = [s.root]
        i = 1
        while i < len(list):
            cur_root = q.pop(0)
            if list[i]:
                cur_root.left = BinaryTree.Node(list[i])
                q.append(cur_root.left)
            i+=1
            if i < len(list) and list[i]:
                cur_root.right = BinaryTree.Node(list[i])
                q.append(cur_root.right)
            i+=1

    def show_tree(s):
        """generated by chatgpt"""
        def add_edges(graph:DiGraph, node: BinaryTree.Node, pos, x=0, y=0, layer=1):
            pos[node.val] = (x, y)
            if node.left:
                graph.add_edge(node.val, node.left.val)
                l = x - 1 / layer
                add_edges(graph, node.left, pos, l, y - 1, layer + 1)
            if node.right:
                graph.add_edge(node.val, node.right.val)
                r = x + 1 / layer
                add_edges(graph, node.right, pos, r, y - 1, layer + 1)
        
        graph = nx.DiGraph()
        pos = {}
        add_edges(graph, s.root, pos)
        nx.draw(graph, pos, with_labels=True, arrows=False)
        plt.show()
    
    @staticmethod
    def _private_static_find(r:Node,val):
        if r is None:
            print('the tree is empty')
            return

        stack = [r]
        while stack:
            cur_node = stack.pop()
            if cur_node.val == val:
                return cur_node
            if cur_node.right: stack.append(cur_node.right)
            if cur_node.left: stack.append(cur_node.left)

        print('the node value doesnt exist')
        return
    
    def find(s, val):
        return BinaryTree._private_static_find(s.root,val)

    @staticmethod
    def _static_find(root:Node, val):
        return BinaryTree._private_static_find(root,val)

    @staticmethod
    def _static_get_leaves(node:Node) -> List[Node]:
        if BinaryTree._static_is_leaf(node):
            print('no leaves')
            return
        children = []
        if node.left: children.append(node.left)
        if node.right: children.append(node.right)
        return children
    
    @staticmethod
    def _static_is_leaf(node:Node) -> bool:
        return not (node.left or node.right)

    def is_empty(s) -> bool: 
        return s.root is None

    def remove(s,node:Node):
        stack = [s.root]
        while stack:
            cur_node = stack.pop()
            if cur_node.right:
                if cur_node.right.val == node.val:
                    cur_node.right = None
                    return
                stack.append(cur_node.right)
            if cur_node.left:
                if cur_node.left.val == node.val:
                    cur_node.left = None
                    return
                stack.append(cur_node.left)
        print('node not found')

    def parent(s,node:Node):
        stack = [s.root]
        while stack:
            cur_node = stack.pop()
            if cur_node.right:
                if cur_node.right.val == node.val:
                    return cur_node
                stack.append(cur_node.right)
            if cur_node.left:
                if cur_node.left.val == node.val:
                    return cur_node
                stack.append(cur_node.left)
            
        print('parent not found')
        return

    def get_height(s)->int:
        if s.is_empty():
            print('tree is empty')
            return
        q = [s.root]
        h = -1
        while q:
            cur_level = len(q)
            for _ in range(cur_level):
                cur_node = q.pop(0)
                if cur_node.left: q.append(cur_node.left)
                if cur_node.right: q.append(cur_node.right)
            h+=1
        return h

    def get_depth(s,node)->int:
        pass

    def is_siblings(s,node1:Node,node2:Node)->bool:
        pass

    def is_cousins(s,node1:Node,node2:Node)->bool:
        pass

def practice_binary_tree():
    bt = BinaryTree()
    
    bt.init_tree([1,2,3,4,5,6,7])

    subtree = bt.find(3)

    for leaf in BinaryTree._static_get_leaves(subtree):
        print(leaf.val)

    BinaryTree._static_find(subtree,5)

    print(BinaryTree._static_is_leaf(subtree))
    print(BinaryTree._static_is_leaf(subtree.right))

    subtree.left.left = BinaryTree.Node(8)
    subtree.left.right = BinaryTree.Node(9)
    subtree.val = 10

    print(bt.parent(bt.find(9)).val)

    print(bt.get_height())

    bt.remove(bt.find(6))

    print(bt.get_height())

    bt.show_tree()

    # bt.init_tree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
    # bt.show_tree()

    # bt.init_tree([1,2,3,None,4,5,None,6,7,None,9,None,None,None,None,10,11])
    # bt.show_tree()